import anyio
import json
from dotenv import load_dotenv
from loguru import logger
from typing import Optional
from pydantic import BaseModel, Field
from langchain_openai import ChatOpenAI

from mcp.server.elicitation import (
    AcceptedElicitation,
    DeclinedElicitation,
    CancelledElicitation,
)
from langchain_core.prompts import (
    ChatPromptTemplate,
    MessagesPlaceholder,
)
from langchain.output_parsers import OutputFixingParser, PydanticOutputParser


from mcp.server.fastmcp import FastMCP, Context

load_dotenv()

mcp_server = FastMCP("Investment MCP Server", port=8001, host="0.0.0.0")

STEPS = [
    (
        "purpose",
        "Step 1, The user is defining their investment purpose. Ask them why they are investing — for example, retirement, wealth growth, education, or a major purchase. If a purpose is provided, confirm.",
    ),
    (
        "timeline",
        "Step 2, The user is specifying their investment timeline. Ask how long they plan to keep the investment — short-term (1–3 years), medium-term (3–7 years), or long-term (7+ years). If a value is given, confirm and ask if they need liquidity before then.",
    ),
    (
        "risk_tolerance",
        "Step 3, The user is describing their risk tolerance. Ask how comfortable they are with potential losses in exchange for potential returns. If a level (low, moderate, high) is provided, confirm and ask for past experience or examples.",
    ),
    (
        "investment_entry",
        "Step 4, The user is entering how they plan to invest. Ask how much they plan to invest and whether it's a one-time or recurring investment. If they mention an amount or product (e.g., ETFs), confirm and ask about timing or strategy.",
    ),
]


class ElicitationResponse(BaseModel):
    user_message: Optional[str] = Field(default=None)


class InvestmentStepOutput(BaseModel):
    """
    Structured output model for each step in the investment profiling flow.

    This model is used to capture the assistant's user-facing message along with
    any structured investment data extracted from the user's response.

    If `investment_data` is present, it indicates that the step has been successfully
    completed and the flow can proceed to the next stage. If it is `None`, further
    clarification or input is needed from the user.
    """

    ai_message: Optional[str] = Field(
        default=None,
        description=(
            "The message generated by the assistant to be shown to the user. "
            "It typically contains a question, confirmation, or clarification request."
        ),
    )
    investment_data: Optional[str] = Field(
        default=None,
        description=(
            "Structured data extracted from the user's input, such as 'retirement', "
            "'10 years', or 'moderate'. If None, the assistant is still collecting input."
        ),
    )


class InvestmentOutput(BaseModel):
    purpose: Optional[str] = Field(default=None)
    timeline: Optional[str] = Field(default=None)
    risk_tolerance: Optional[str] = Field(default=None)
    investment_entry: Optional[str] = Field(default=None)


async def retrieve_agent_chain():
    llm = ChatOpenAI(model="o3-2025-04-16", streaming=False)
    system_message = """
        You are an intelligent and adaptive investment assistant designed to guide users through a step-by-step 
        process to define their investment profile. Your role is to gather input for the following stages: 
        purpose, timeline, risk tolerance, and investment entry. 

        At each step, you will receive a step name and a related parameter value. 
        Based on this, generate a relevant, concise, and professional prompt to confirm or elicit 
        information from the user. Be clear, avoid jargon, and aim to complete the investment profile through 
        conversational interaction. Use previous context if available to enhance personalization.
        
        Now handle the current step:
        {step_prompt}
        
        Your task is to:
            - Generate a concise, user-facing message (`ai_message`) asking for or confirming information.
            - If the user's input (parameter) is sufficient to proceed, extract it into the `investment_data` field. Otherwise, leave `investment_data` as null and guide the user to clarify.
        
            - If `investment_data` is provided (i.e. already filled), simply thank the user for their response.
            - Do **not** ask any follow-up questions or mention the next step.

        Always respond in **this JSON structure**:
        {{
          "ai_message": "string",  
          "investment_data": "string or null"
        }}
        
        If the investment_data field is filled, simply thank the user. Do not mention anything about the next step.    
        
        """
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", system_message),
            MessagesPlaceholder(variable_name="chat_history"),
            ("user", "{input}"),
        ]
    )
    output_parser = OutputFixingParser.from_llm(
        parser=PydanticOutputParser(pydantic_object=InvestmentStepOutput),
        llm=llm,
        max_retries=3,
    )
    agent_chain = prompt | llm | output_parser
    return agent_chain


@mcp_server.tool(name="elicit-investment-conversation")
async def elicit_investment_conversation(
    ctx: Context, session_id: str
) -> InvestmentOutput:
    chat_history = []
    investment_output = InvestmentOutput()
    agent_chain = await retrieve_agent_chain()

    for step_name, step_prompt in STEPS:
        user_message = ""
        step_output = None
        retrieve_output = True

        while step_output is None:
            try:
                ai_output = await agent_chain.ainvoke(
                    input={
                        "input": user_message,
                        "step_prompt": step_prompt,
                        "chat_history": chat_history,
                    }
                )

                if ai_output.investment_data:
                    retrieve_output = False
                    step_output = ai_output.investment_data

                response = await ctx.elicit(
                    message=json.dumps(
                        {
                            "session_id": session_id,
                            "retrieve_output": retrieve_output,
                            "ai_message": ai_output.ai_message,
                            "step_name": step_name,
                        }
                    ),
                    schema=ElicitationResponse,
                )

                match response:
                    case AcceptedElicitation(data=data):
                        user_message = data.user_message
                    case DeclinedElicitation():
                        break
                    case CancelledElicitation():
                        break

            except (anyio.ClosedResourceError, ConnectionError) as e:
                logger.exception(e)
                raise e
            except Exception as e:
                logger.exception(e)
                raise e

        setattr(investment_output, step_name, step_output)

    return investment_output


if __name__ == "__main__":
    mcp_server.run(transport="streamable-http")
